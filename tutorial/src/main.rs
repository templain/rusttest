fn main() {
    let x = 5; // 変数束縛。型推論によりi32になる。デフォルトではイミュータブル
    let (a, b) = (1, 2); // パターンによる変数束縛(分配束縛）
    let y: i32 = 5; // 明示的に型を書く
    let mut z = 3; // ミュータブル（再代入可能）
    println!("The value of x is {}", x); // {}のところにxの値が表示される
    {
        let z = 3; // このブロックからのみアクセス可能
    }
    let z = x; // 同じ名前の変数束縛があると以前の束縛が上書きされる
    println!("1 + 2 = {}", calc_sum(1, 2));
    let f: fn(i32, i32) -> i32 = calc_sum; // 関数ポインタ
    let af = f(1, 2);
    let x = 'x'; // char型はユニコードのスカラ値(4byte)
    let x: isize = 1; // マシンのポインタのサイズに依存
    let x = [1, 2, 3]; // [i32; 3]という型の配列
    let x = [0; 20]; // 20個の要素を0で初期化
    let y = x.len(); // 配列の要素の個数
    let y = &x[1..2]; // スライスは他のデータ構造への参照でコピーはしない
    let y: (i32, &str) = (1, "hello"); // タプル
    let y = (1,); // 1要素のタプル
    let z = y.0; // タプルのフィールドにはインデックス構文でアクセス
    let x = 5;
    let y = if x == 5 { 10 } else { 15 }; // ifは式なのでこのように書ける
    for x in 0..10 { // RustではCスタイルのforループはない
        println!("{}", x);
    }
    for (i, j) in (5..10).enumerate() { // 何回目の繰り返しなのかがiでわかる
        println!("i = {} and j = {}", i, j);
    }
    'outer: for x in 0..10 { // ループに対するラベル
        println!("x:{}", x);
    }
    let v = vec![1,2,3];
    let v2 = v; // 所有権がvからv2に転送されたのでvはもう使えない
    take(v2); // 関数に引数として渡しても所有権が転送される
    let v3 = 1;
    let v4 = v3; // v3はi32でCopyトレイトを実装しているのでコピーが作られる。v3はこれ以降も使える。全てのプリミティブ型はCopyトレイトを実装している
}

fn take(v: Vec<i32>) -> ! {
    panic!("TEST");
}

fn calc_sum(x: i32, y: i32) -> i32 {
    // return x + y; // 早期リターンの場合はreturnを使う
    // Rustには2種類の文（宣言文、式文）がある。その他は全て式である。
    let mut a = 1;
    // 割り当てられる値には単一の所有者しかいない
    let b = (a = 2); // 割り当ての値は空のタプルになる（bは2ではない）
    x + y // セミコロンをつけなければ式になる。つけると式文になるので()を返す。
}

fn diverges() -> ! {
    // 値を返さない場合は「!」型を指定。発散する関数という。
    panic!("This function never returns!"); // メッセージを出力しクラッシュする
}
